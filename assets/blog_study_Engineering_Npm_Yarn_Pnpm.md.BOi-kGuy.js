import{_ as n,c as a,o as p,a4 as e,al as o,am as r}from"./chunks/framework.DwS4PCXf.js";const P=JSON.parse('{"title":"Npm&Yarn&Pnpm","description":"","frontmatter":{"outline":"deep"},"headers":[],"relativePath":"blog/study/Engineering/Npm&Yarn&Pnpm.md","filePath":"blog/study/Engineering/Npm&Yarn&Pnpm.md"}'),t={name:"blog/study/Engineering/Npm&Yarn&Pnpm.md"},m=e('<h1 id="npm-yarn-pnpm" tabindex="-1">Npm&amp;Yarn&amp;Pnpm <a class="header-anchor" href="#npm-yarn-pnpm" aria-label="Permalink to &quot;Npm&amp;Yarn&amp;Pnpm&quot;">​</a></h1><hr><div class="tip custom-block"><p class="custom-block-title">pnmp 相对于 yarn/npm 的优势</p><ol><li>更快的依赖下载</li><li>更高效的利用磁盘空间</li><li>更为优秀的依赖管理</li></ol></div><h3 id="问题一-依赖嵌套-npm2" tabindex="-1">问题一：依赖嵌套（npm2 <a class="header-anchor" href="#问题一-依赖嵌套-npm2" aria-label="Permalink to &quot;问题一：依赖嵌套（npm2&quot;">​</a></h3><p>用 node 版本管理工具把 node 版本降到 4，那 npm 版本就是 2.x 了。</p><img src="'+o+'" style="zoom:50%;"><p>1、多个包难免会有公共依赖，同样的依赖复制多次，磁盘占用大，下载速度慢</p><p>2、致命问题 windows 的文件路径最长 260 多个字符，这样的嵌套会超过 windows 路径的长度限制</p><h3 id="问题二-幽灵依赖-npm3-yarn" tabindex="-1">问题二：幽灵依赖 （npm3 yarn <a class="header-anchor" href="#问题二-幽灵依赖-npm3-yarn" aria-label="Permalink to &quot;问题二：幽灵依赖 （npm3 yarn&quot;">​</a></h3><p>yarn 将所有依赖 <strong>铺平</strong> 这样就不会依赖重复多次的问题，同时也解决了路路径名字问题</p><img src="'+r+'" style="zoom:50%;"><p>1、我们明明没有安装的 A 包 但是却可以在 JS 中 引用，这是因为我们引用了 B 包，但是 B 包中依赖了 A 包，平铺在 node_module 中。如果某一天，我们不需要 B 包，那么代码中引用 A 包的代码将会报错</p><h3 id="主角-pnpm" tabindex="-1">主角：pnpm <a class="header-anchor" href="#主角-pnpm" aria-label="Permalink to &quot;主角：pnpm&quot;">​</a></h3><p><strong>优点一：节省磁盘</strong> pnpm 安装的真实包，都存在一个系统的隐藏路径 .pnpm-store 文件中 ，项目中的依赖只是对真实包的引用。这样十个项目的 node_module 中相同的依赖只用下载一份在 隐藏文件中 引用即可</p><p><strong>优点二：效率快</strong> pnpm 在你删除项目的某个依赖或者升级依赖的时候不会把 store 里的真实文件删除（除非执行 pnpm prune 指令 ，要求他杀出不被使用到的 store）。在切换分支，版本切换不出错，且效率跟高</p><p><strong>优点三：依赖合理 不拍平</strong> 没有幽灵依赖，所有依赖都在 store 中，只是没有把引用开放给你。</p><p><strong>优点四：支持 workspace 可以做 monorepo（微应用</strong></p>',17),s=[m];function i(l,d,c,_,h,g){return p(),a("div",null,s)}const b=n(t,[["render",i]]);export{P as __pageData,b as default};
