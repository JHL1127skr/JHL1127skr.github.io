import{_ as s,c as i,o as a,a4 as n,aD as e}from"./chunks/framework.DwS4PCXf.js";const y=JSON.parse('{"title":"虚拟 DOM","description":"","frontmatter":{"outline":"deep"},"headers":[],"relativePath":"blog/study/React/Diff.md","filePath":"blog/study/React/Diff.md"}'),t={name:"blog/study/React/Diff.md"},l=n('<h1 id="虚拟-dom" tabindex="-1">虚拟 DOM <a class="header-anchor" href="#虚拟-dom" aria-label="Permalink to &quot;虚拟 DOM&quot;">​</a></h1><hr><h3 id="虚拟-dom-virtual-dom" tabindex="-1">虚拟 DOM（Virtual DOM） <a class="header-anchor" href="#虚拟-dom-virtual-dom" aria-label="Permalink to &quot;虚拟 DOM（Virtual DOM）&quot;">​</a></h3><h3 id="一、什么是虚拟-dom" tabindex="-1">一、什么是虚拟 DOM <a class="header-anchor" href="#一、什么是虚拟-dom" aria-label="Permalink to &quot;一、什么是虚拟 DOM&quot;">​</a></h3><p>本质是 JS 跟 DOM 的一个映射缓存，形态上表现为一个能够描述 DOM 结构及其属性信息的 JS 对象 <img src="'+e+`" alt=""></p><h4 id="二、虚拟-dom-的价值到底是什么-解决了什么问题" tabindex="-1">二、虚拟 DOM 的价值到底是什么（解决了什么问题） <a class="header-anchor" href="#二、虚拟-dom-的价值到底是什么-解决了什么问题" aria-label="Permalink to &quot;二、虚拟 DOM 的价值到底是什么（解决了什么问题）&quot;">​</a></h4><p>1、研发体验/研发效率的问题<br> 2、跨平台多端开发 同一套虚拟 DOM 可以渲染在不同的载体<br> 3、“批量更新”</p><h3 id="diff-算法" tabindex="-1">Diff 算法 <a class="header-anchor" href="#diff-算法" aria-label="Permalink to &quot;Diff 算法&quot;">​</a></h3><h4 id="一、什么是-diff-算法" tabindex="-1">一、什么是 diff 算法 <a class="header-anchor" href="#一、什么是-diff-算法" aria-label="Permalink to &quot;一、什么是 diff 算法&quot;">​</a></h4><blockquote><p><strong>算法的核心就是复用节点</strong></p></blockquote><p>在 v16 之前:React 通过递归直接生成虚拟 DOM，setState 触发重新渲染，对比生成新旧虚拟 DOM，对比差异渲染真实的 DOM<br> 在 v16 之后:为了优化性能，先将虚拟 DOM 转化为 Fiber，也就是将树转换成链表，然后再渲染，整体渲染流程分成了两个阶段<br></p><p>render ： 从虚拟 DOM 转换成 Fiber，并且对需要 dom 操作的节点打上 effectTag 的标记<br> commit：对有 effectTag 标记的 fiber 节点进行 dom 操作，并执行所有的 effect 副作用函数<br></p><blockquote><p>vdom -&gt; fiber 这个过程称之为 reconcile（调和），是可以被打断的，由 scheduler 调度执行</p></blockquote><h4 id="二、react-预设的三个限制" tabindex="-1">二、React 预设的三个限制 <a class="header-anchor" href="#二、react-预设的三个限制" aria-label="Permalink to &quot;二、React 预设的三个限制&quot;">​</a></h4><p>1、只对同层级元素进行 Diff。如果一个 DOM 元素前后跨越了层级，那么 React 不会尝试复用它<br> 2、两个不同类型的元素会产生不同的树。即销毁原组件，创建新组件。<br> 3、开发者可以通过 Key 来暗示子元素在不同的渲染下保持稳</p><h4 id="三、具体实现" tabindex="-1">三、具体实现 <a class="header-anchor" href="#三、具体实现" aria-label="Permalink to &quot;三、具体实现&quot;">​</a></h4><p>入口函数 <code>reconcileChildFibers()</code></p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 根据newChild类型选择不同diff函数处理</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> reconcileChildFibers</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span></span>
<span class="line"><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">	returnFiber</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Fiber</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">	currentFirstChild</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Fiber</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> |</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> null</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">	newChild</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> any</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Fiber</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> |</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> null</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">	const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> isObject</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> typeof</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> newChild </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">===</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;object&quot;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> &amp;&amp;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> newChild </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!==</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> null</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">	if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (isObject) {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">		// object类型，可能是 REACT_ELEMENT_TYPE 或 REACT_PORTAL_TYPE</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">		switch</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (newChild.$typeof) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">			case</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> REACT_ELEMENT_TYPE</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">			// 调用 reconcileSingleElement 处理</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">			// ...其他case</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">		}</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">	if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">typeof</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> newChild </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">===</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;string&quot;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> ||</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> typeof</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> newChild </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">===</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;number&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">		// 调用 reconcileSingleTextNode 处理</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">	if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">isArray</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(newChild)) {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">		// 调用 reconcileChildrenArray 处理</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">	// 一些其他情况调用处理函数</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">	// 以上都没有命中，删除节点</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">	return</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> deleteRemainingChildren</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(returnFiber, currentFirstChild);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h4 id="第一轮遍历-尝试逐个复用节点" tabindex="-1">第一轮遍历：尝试逐个复用节点 <a class="header-anchor" href="#第一轮遍历-尝试逐个复用节点" aria-label="Permalink to &quot;第一轮遍历：尝试逐个复用节点&quot;">​</a></h4><p>遍历 JSX 对象（newChildren 数组）去和 Fiber 节点对比（链表）<br> 判断 key 和 type（节点类型，如 div、p、span、函数组件名），如果都相同则复用，不同跳出整个遍历。</p><h4 id="第二轮遍历-处理剩下的节点" tabindex="-1">第二轮遍历：处理剩下的节点 <a class="header-anchor" href="#第二轮遍历-处理剩下的节点" aria-label="Permalink to &quot;第二轮遍历：处理剩下的节点&quot;">​</a></h4><p><strong>情况 1：只剩旧 Fiber 节点</strong><br> 说明更新需要的新 Fiber 节点已经创建完毕，遍历剩余的旧 Fiber 节点依次执行删除操作（放入父 fiber 节点的 deletions 数组中）</p><p><strong>情况 2：只剩新 JSX 节点</strong><br> 说明旧的 Fiber 节点都已复用，遍历剩余的 JSX 节点依次执行插入操作 （打上 Placement 标记）</p><p><strong>情况 3：新旧子节点都有剩 （重点</strong>）<br> 将剩下的旧 Fiber 节点放入以 key 为 key，以 fiber 为 value 的 Map 对象中，在遍历余下的 JSX 对象，通过 key 索引就能在 map 中找到对应的 Fiber。</p><p><code>oldIndex</code>：旧 Fiber 节点中对应的索引 <br><code>lastplacedIndex</code>：最后一个可复用的节点在旧 Fiber 节点中的位置索引</p><p>如果 <code>oldIndex &gt;= lastPlacedIndex</code> 代表该可复用节点不需要移动 ，并将 <code>lastPlacedIndex = oldIndex; </code><br> 如果 <code>oldIndex &lt; lastplacedIndex </code>该可复用节点之前插入的位置索引小于这次更新需要插入的位置索引，代表该节点需要向右移动</p>`,26),h=[l];function p(k,r,d,o,c,E){return a(),i("div",null,h)}const F=s(t,[["render",p]]);export{y as __pageData,F as default};
