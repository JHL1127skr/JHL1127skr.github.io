import{_ as e,c as a,o as s,a4 as o}from"./chunks/framework.A-dsNYHP.js";const f=JSON.parse('{"title":"React","description":"","frontmatter":{"outline":"deep"},"headers":[],"relativePath":"blog/interview/React.md","filePath":"blog/interview/React.md"}'),t={name:"blog/interview/React.md"},i=o(`<h1 id="react" tabindex="-1">React <a class="header-anchor" href="#react" aria-label="Permalink to &quot;React&quot;">​</a></h1><h3 id="redux-工作流程" tabindex="-1">Redux 工作流程 <a class="header-anchor" href="#redux-工作流程" aria-label="Permalink to &quot;Redux 工作流程&quot;">​</a></h3><p>派发<code>dispatch</code>触发 <code>action</code>，对应<code>reducer</code>处理，改变<code>store</code></p><h3 id="redux-三大原则" tabindex="-1">Redux 三大原则 <a class="header-anchor" href="#redux-三大原则" aria-label="Permalink to &quot;Redux 三大原则&quot;">​</a></h3><ol><li>单一数据源：全局的<code>state</code>被储存在一颗<code>object tree</code>。并且这棵树只存在唯一的一个<code>store</code>中</li><li><code>state</code>只读：只能通过<code>action</code>改变<code>state</code></li><li>使用纯函数来执行修改：为了描述<code>acrion</code>如何修改<code>state</code>，你需要编写纯函数<code>reducer</code></li></ol><h3 id="高阶组件平时使用过没" tabindex="-1">高阶组件平时使用过没 <a class="header-anchor" href="#高阶组件平时使用过没" aria-label="Permalink to &quot;高阶组件平时使用过没&quot;">​</a></h3><ol><li>渲染劫持，可以控制组件时候渲染。比如权限组件</li><li>强化 Props，可以向原始组件混入一些<code>props</code>。比如 <code>withRoute</code></li></ol><h3 id="react-批处理-同步异步" tabindex="-1">React 批处理 （同步异步） <a class="header-anchor" href="#react-批处理-同步异步" aria-label="Permalink to &quot;React 批处理 （同步异步）&quot;">​</a></h3><ol><li>React18 之前 <ul><li>开启：在 React 内部触发的监听事件当中（异步</li><li>关闭: 原生的事件中或者<code>setTimeout</code> （同步</li></ul></li><li>React18 之后 <ul><li>开启：不管是原生事件还是 React 内部统一批处理</li><li>关闭：通过<code>flushSync(()=&gt;{})</code>，实现手动关闭（注：函数内部多次 setState 仍为批处理</li></ul></li></ol><h3 id="react-合成事件" tabindex="-1">React 合成事件 <a class="header-anchor" href="#react-合成事件" aria-label="Permalink to &quot;React 合成事件&quot;">​</a></h3><p>16:原生事件先触发 冒泡到 docuemnt 上 统一执行合成事件<br> 17:先执行合成事件的捕获，原生事件执行完毕执行冒泡阶段的合成事件</p><blockquote><p>注：在原生事件中阻止冒泡行为，会阻止 React 合成事件的传播</p></blockquote><h3 id="react-闭包陷阱" tabindex="-1">React 闭包陷阱 <a class="header-anchor" href="#react-闭包陷阱" aria-label="Permalink to &quot;React 闭包陷阱&quot;">​</a></h3><p>没有办法拿到最新的值，因为函数组件每次重新渲染都会产生新的作用域<br> 解决办法：<code>useRef</code> 因为返回的都是都一个对象，更新产生的 ref 指向的也是同一片内存</p><h3 id="react-中有哪些性能优化的方式" tabindex="-1">React 中有哪些性能优化的方式 <a class="header-anchor" href="#react-中有哪些性能优化的方式" aria-label="Permalink to &quot;React 中有哪些性能优化的方式&quot;">​</a></h3><ol><li>class 中 <code>shouldComponentUpdate</code> 与 <code>pureComponent</code></li><li>hooks 中 <code>usememo</code>、<code>useCallback</code>、<code>React.memo()</code></li><li>列表渲染中增加 key 属性</li><li>合理规划组件 将变<code>(state,props,context)</code>与不变相分离，减少组件渲染次数</li><li>避免使用匿名函数</li><li><code>React.lazy</code> 与 <code>React.Supense</code></li></ol><h3 id="hooks-使用上有什么限制" tabindex="-1">Hooks 使用上有什么限制 <a class="header-anchor" href="#hooks-使用上有什么限制" aria-label="Permalink to &quot;Hooks 使用上有什么限制&quot;">​</a></h3><ol><li>不要在循环、判断或嵌套函数中使用</li><li>在 React 的函数组件中使用</li></ol><h3 id="正确使用-usememo" tabindex="-1">正确使用 useMemo <a class="header-anchor" href="#正确使用-usememo" aria-label="Permalink to &quot;正确使用 useMemo&quot;">​</a></h3><blockquote><p>useCallback 是 useMemo 的语法糖</p></blockquote><ol><li>防止由重新渲染而带来的不必要的重复计算</li><li>搭配<code>React.memo()</code>防止子组件</li></ol><h3 id="useeffect-相关" tabindex="-1">useEffect 相关 <a class="header-anchor" href="#useeffect-相关" aria-label="Permalink to &quot;useEffect 相关&quot;">​</a></h3><ol><li><strong><code>useEffect</code></strong> 会在<code>commit</code>阶段完成后<strong>异步执行</strong>，适用于多数场景</li><li><strong><code>useLayoutEffect</code></strong> 会在<code>commit</code>阶段的<code>Layout</code>子阶段<strong>同步</strong>执行，主要处理 DOM 操作、调整样式、避免页面闪烁的问题</li><li><strong><code>useInsertionEffect</code></strong> 会在<code>commit</code>阶段的<code>Mutation</code>子阶段<strong>同步</strong>执行，无法访问“对 DOM 的引用”，适用于 css in js</li></ol><h3 id="如何让-useeffect-支持-async-await" tabindex="-1">如何让 useEffect 支持 async...await <a class="header-anchor" href="#如何让-useeffect-支持-async-await" aria-label="Permalink to &quot;如何让 useEffect 支持 async...await&quot;">​</a></h3><p><strong>Q:为什么不支持</strong> <br> A:在<code>useEffect</code>的回调函数中应该<strong>不返回任何内容</strong> 或者 <strong>返回清理函数 cleanUp</strong>，如果是<code>async()=&gt;{}</code>,返回值将会是一个 Promise，不能作为函数调用。</p><p><strong>Q:如何支持</strong> <br></p><ol><li>直接在函数内定义在执行</li><li>在函数使用 IIFE（立即执行函数）</li><li>自定义 hooks</li></ol><h3 id="useref-使用" tabindex="-1">useRef 使用 <a class="header-anchor" href="#useref-使用" aria-label="Permalink to &quot;useRef 使用&quot;">​</a></h3><ol><li>可以作为变量储存，且永远指向的同一片内存，不受闭包陷阱的限制</li><li>将 ref 直接绑定在 DOM 上以便开发者获取 DOM</li></ol><p><strong>问题：</strong> 但可能开发者过于操控 DOM，导致和 React 内部操控 DOM 的行为产生冲突。<br><strong>限制：</strong> 所以可以通过包裹组件的方式实现隔离效果，没有办法跨过组件直接获取 DOM。<br><strong>解决：</strong> 可以使用<code>forwardRef((props,ref)=&gt;{})</code>包裹组件，传入 ref 到组件内部与 DOM 绑定。并且通过 React 内部的 Hooks <code>useImperativeHandle</code>，可以自定义返回 ref 的值</p><h3 id="usetransition-与-usedeferredvalue" tabindex="-1">useTransition 与 useDeferredValue <a class="header-anchor" href="#usetransition-与-usedeferredvalue" aria-label="Permalink to &quot;useTransition 与 useDeferredValue&quot;">​</a></h3><div class="language-jsx vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">jsx</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">isPending</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">startTransition</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> useTransition</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// isPending:boolean 是否在等待（低优先级任务是否在执行）</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// startTransition(()=&gt;{}) 回调函数中的任务会被降为低优先级</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> deferredValue</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> useDeferredValue</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(value);</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 将该值转成 低优先处理。（本质同上，一个包装方法，一个包装值</span></span></code></pre></div>`,32),l=[i];function c(r,n,d,h,u,p){return s(),a("div",null,l)}const g=e(t,[["render",c]]);export{f as __pageData,g as default};
