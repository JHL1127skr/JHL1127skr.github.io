import{_ as e,c as r,o as a,a4 as t,aF as o}from"./chunks/framework.DwS4PCXf.js";const f=JSON.parse('{"title":"Fiber 架构：未完成","description":"","frontmatter":{"outline":"deep"},"headers":[],"relativePath":"blog/study/React/FIber.md","filePath":"blog/study/React/FIber.md"}'),i={name:"blog/study/React/FIber.md"},c=t('<h1 id="fiber-架构-未完成" tabindex="-1">Fiber 架构：未完成 <a class="header-anchor" href="#fiber-架构-未完成" aria-label="Permalink to &quot;Fiber 架构：未完成&quot;">​</a></h1><hr><h3 id="fiiber-的出现" tabindex="-1">FIiber 的出现 <a class="header-anchor" href="#fiiber-的出现" aria-label="Permalink to &quot;FIiber 的出现&quot;">​</a></h3><p>随着业务复杂繁重，React 15 中的栈调和（Stack Reconciler ）是一个同步递归的过程，漫长不可打断的同步渲染进程会带来一定风险。</p><h3 id="什么是-fiber" tabindex="-1">什么是 Fiber <a class="header-anchor" href="#什么是-fiber" aria-label="Permalink to &quot;什么是 Fiber&quot;">​</a></h3><blockquote><p>Fiber 就是比线程还要纤细的一个过程，也就是所谓的“纤程”，纤程的出现意在渲染过程实现更加精细的控制</p></blockquote><p>一、从架构角度来看：Fiber 是对 React 核心算法的重写<br> 二、从编码角度来看：Fiber 是 React 内部定义的一种数据结构<br> 三、从工作流的角度来看：Fiber 节点保存了组件需要更新的状态和副作用</p><blockquote><p>Fiber 架构的应用目的是实现 <strong>“增量渲染”</strong></p></blockquote><p>所谓“增量渲染”就是把一个渲染任务分解成多个渲染任务，将其分散到多个帧里面， “增量渲染” 目的是实现任务的<strong>可中断</strong>、<em>可恢复</em>、不同的任务不同的<strong>优先级</strong>，达成更加顺滑的用户体验</p><p><img src="'+o+'" alt="图片"></p><p>对比 React15 Fiber 架构增加了调度器 <strong>Scheduler</strong></p><h3 id="fiber-架构核心-可中断-、-可恢复-、-优先级" tabindex="-1">Fiber 架构核心：“可中断”、“可恢复”、“优先级” <a class="header-anchor" href="#fiber-架构核心-可中断-、-可恢复-、-优先级" aria-label="Permalink to &quot;Fiber 架构核心：“可中断”、“可恢复”、“优先级”&quot;">​</a></h3><p>优先级：每个更新任务都会被赋予一个优先级</p><p>可中断：若发现 B 的优先级高于当前任务 A，那么当前处于 Reconciler 层的 A 任务就会被中断</p><p>可恢复：A 任务将会被重新推入 Reconciler 层，继续他的渲染之旅，这便是所谓的“可恢复”</p>',15),b=[c];function s(n,l,p,d,_,h){return a(),r("div",null,b)}const F=e(i,[["render",s]]);export{f as __pageData,F as default};
