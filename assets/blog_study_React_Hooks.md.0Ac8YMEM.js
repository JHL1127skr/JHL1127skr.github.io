import{_ as a,c as o,o as t,a4 as s,aB as e,aC as l}from"./chunks/framework.A-dsNYHP.js";const _=JSON.parse('{"title":"React-Hooks设计思：未完成","description":"","frontmatter":{"outline":"deep"},"headers":[],"relativePath":"blog/study/React/Hooks.md","filePath":"blog/study/React/Hooks.md"}'),i={name:"blog/study/React/Hooks.md"},c=s('<h1 id="react-hooks设计思-未完成" tabindex="-1">React-Hooks设计思：未完成 <a class="header-anchor" href="#react-hooks设计思-未完成" aria-label="Permalink to &quot;React-Hooks设计思：未完成&quot;">​</a></h1><hr><div class="tip custom-block"><p class="custom-block-title">类组件</p><p>面向对象编程思想的一种表征</p><ul><li><strong>封装</strong>：将一类属性和方法，“聚拢”到一个Class里去</li><li><strong>继承</strong>：新的Class可以通过继承现有Class实现对某一类属性的方法和使用</li></ul></div><div class="tip custom-block"><p class="custom-block-title">函数组件</p><p>函数组件会捕获render内部的状态，这是两类组件最大的不同 <a href="https://zhuanlan.zhihu.com/p/62767474" target="_blank" rel="noreferrer">参考</a></p></div><div class="tip custom-block"><p class="custom-block-title">类组件与函数组件的区别</p><ul><li>类组件需要继承class，函数组件不需要</li><li>类组件可以访问生命周期方法，函数组件不能</li><li>类组件可以获取到实例化后的this，并基于这个this做各样的事情，而函数不能</li><li>类组件中可以定义并维护state（状态），而函数组件不可以</li></ul></div><h3 id="为什么需要react-hooks" tabindex="-1">为什么需要React-Hooks <a class="header-anchor" href="#为什么需要react-hooks" aria-label="Permalink to &quot;为什么需要React-Hooks&quot;">​</a></h3><h4 id="一、告别难以理解的class" tabindex="-1">一、告别难以理解的Class <a class="header-anchor" href="#一、告别难以理解的class" aria-label="Permalink to &quot;一、告别难以理解的Class&quot;">​</a></h4><ol><li>this指向问题</li><li>生命周期的学习成本以及不合理的逻辑规划方式（业务逻辑与生命周期耦合）</li></ol><h4 id="二、解决业务逻辑难以拆分的问题" tabindex="-1">二、解决业务逻辑难以拆分的问题 <a class="header-anchor" href="#二、解决业务逻辑难以拆分的问题" aria-label="Permalink to &quot;二、解决业务逻辑难以拆分的问题&quot;">​</a></h4><h4 id="三、使状态逻辑复用变得简单可行" tabindex="-1">三、使状态逻辑复用变得简单可行 <a class="header-anchor" href="#三、使状态逻辑复用变得简单可行" aria-label="Permalink to &quot;三、使状态逻辑复用变得简单可行&quot;">​</a></h4><p>类组件中靠的是高阶组件（HOC）和Render Props，现在我们通过自定义Hook达到既不破坏组件结构、又能实现逻辑复用效果</p><h4 id="四、函数组件从设计思想上来看更加契合react的理念" tabindex="-1">四、函数组件从设计思想上来看更加契合React的理念 <a class="header-anchor" href="#四、函数组件从设计思想上来看更加契合react的理念" aria-label="Permalink to &quot;四、函数组件从设计思想上来看更加契合React的理念&quot;">​</a></h4><h3 id="深入hook工作机制-本质是链表" tabindex="-1">深入Hook工作机制：本质是链表 <a class="header-anchor" href="#深入hook工作机制-本质是链表" aria-label="Permalink to &quot;深入Hook工作机制：本质是链表&quot;">​</a></h3><h4 id="一、hooks使用规则" tabindex="-1">一、Hooks使用规则 <a class="header-anchor" href="#一、hooks使用规则" aria-label="Permalink to &quot;一、Hooks使用规则&quot;">​</a></h4><ol><li>只在React函数中使用Hooks</li><li>不要在循环、条件或者嵌套函数中使用Hook</li></ol><blockquote><p>要确保Hooks在每次渲染时都要保持同样的执行顺序</p></blockquote><h4 id="二、hooks调用链路-单向-顺序链表" tabindex="-1">二、hooks调用链路 - 单向 顺序链表 <a class="header-anchor" href="#二、hooks调用链路-单向-顺序链表" aria-label="Permalink to &quot;二、hooks调用链路 - 单向 顺序链表&quot;">​</a></h4><div class="tip custom-block"><p class="custom-block-title">初始化：</p><p>mountState(首次渲染) 构建链表并渲染</p></div><p><img src="'+e+'" alt="图片"></p><div class="tip custom-block"><p class="custom-block-title">更新：</p><p>updateState 依次遍历链表并渲染</p></div><p><img src="'+l+'" alt="图片"></p><div class="warning custom-block"><p class="custom-block-title">注意：</p><p>hooks的渲染是通过“依次遍历”来定位每个hooks内容的。如果前后两次读到的链表在顺序上出现差异，那么渲染的结果自然是不可控的。</p></div>',22),r=[c];function h(d,n,k,p,u,b){return t(),o("div",null,r)}const q=a(i,[["render",h]]);export{_ as __pageData,q as default};
