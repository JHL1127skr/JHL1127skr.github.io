import{_ as e,c as o,o as t,a4 as c}from"./chunks/framework.DwS4PCXf.js";const b=JSON.parse('{"title":"组件重新渲染","description":"","frontmatter":{"outline":"deep"},"headers":[],"relativePath":"blog/study/React/Render.md","filePath":"blog/study/React/Render.md"}'),d={name:"blog/study/React/Render.md"},s=c('<h1 id="组件重新渲染" tabindex="-1">组件重新渲染 <a class="header-anchor" href="#组件重新渲染" aria-label="Permalink to &quot;组件重新渲染&quot;">​</a></h1><hr><div class="tip custom-block" style="padding-top:8px;"> state、props、context改变都会使组件<b>重新渲染</b></div><blockquote><p><code>Context</code> 提供了一个无需为每层组件手动添加 <code>props</code>，就能在组件树间进行数据传递的方法。正是因为其这个特点，它是可以穿透 <code>React.memo</code> 或者 <code>shouldComponentUpdate</code> 的比对的，也就是说，一旦 <code>Context</code> 的 <code>Value</code> 变动，所有依赖该 <code>Context</code> 的组件会全部 <code>forceUpdate</code></p></blockquote><div class="tip custom-block"><p class="custom-block-title">Q：子组件重新渲染会导致父组件会渲染吗</p><p>A：不会 子组件更新并不会影响 父组件的 <code>props</code> 和 <code>state</code></p></div><div class="tip custom-block"><p class="custom-block-title">Q：子组件没有传入 Props，但父组件更新子组件为什么还是一样会重新渲染</p><p>A：因为 React 内部会默认给子组件传入一个<code>props:{}</code> ,应为每次的 {} 引用地址都不同<code>{}! == {} //true</code>,所以子组件还是会重新渲染</p></div><div class="tip custom-block"><p class="custom-block-title">Q：上述问题有什么好的解决方案吗</p><p>A：React.memo 和 React.pureComponent，他们会对 props 进行 &quot;浅比较&quot;，判断两次是否相等</p></div><div class="tip custom-block"><p class="custom-block-title">Q：还有那些 API 会影响到组件之间的渲染</p><p>A：函数组件 Hooks 中的<code>useMemo</code>、<code>useCallback。</code>类组件中的<code>shouldComponentUpdate</code><br>相同点 该缓存不受函数式组件的重新 render 的控制，只根据依赖的变更才会改变.同时传入子组件时，不会引起子组件的渲染，前提是子组件 需要被<code>React.memo</code>或<code>React.pureComponent</code>包裹<br><code>shouldComponentUpdate</code> 是类组件的勾子函数，通过返回 true/false 来判断是否更新</p></div>',8),a=[s];function p(l,r,n,i,u,m){return t(),o("div",null,a)}const k=e(d,[["render",p]]);export{b as __pageData,k as default};
