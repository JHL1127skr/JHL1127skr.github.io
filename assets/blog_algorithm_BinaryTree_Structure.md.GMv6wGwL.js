import{_ as a,c as t,o as s,a4 as n}from"./chunks/framework.A-dsNYHP.js";const b=JSON.parse('{"title":"","description":"","frontmatter":{"outline":"deep"},"headers":[],"relativePath":"blog/algorithm/BinaryTree/Structure.md","filePath":"blog/algorithm/BinaryTree/Structure.md"}'),l={name:"blog/algorithm/BinaryTree/Structure.md"},e=n(`<h3 id="_1、二叉树种类" tabindex="-1">1、二叉树种类 <a class="header-anchor" href="#_1、二叉树种类" aria-label="Permalink to &quot;1、二叉树种类&quot;">​</a></h3><ul><li>满二叉树：节点为 2的k次方-1</li></ul><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>             1					1</span></span>
<span class="line"><span>           /   \\			  /   \\</span></span>
<span class="line"><span>          2     3			 2     3</span></span>
<span class="line"><span>         / \\   / \\     	    / \\   / </span></span>
<span class="line"><span>        4   5 6   7  ✅    4   5 6    ❌</span></span></code></pre></div><ul><li>完全二叉树：二叉树的底层 从左到右是连续的</li></ul><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>           1				 1				     1</span></span>
<span class="line"><span>         /   \\			   /   \\			   /   \\</span></span>
<span class="line"><span>        2     3			  2     3			  2     3</span></span>
<span class="line"><span>       / \\        		 / \\   / 			 / \\     \\  </span></span>
<span class="line"><span>      4   5      ✅     4  5  6    ✅       4  5     7 ❌</span></span></code></pre></div><ul><li>二叉搜索树：有序树， <ul><li>若左子树存在，那么左子树上所有的节点值都 小于 根节点的值</li><li>若右子树存在，那么右子树上的所有节点值都 大于 根节点的值</li><li>左右子树也分别为 二叉搜索树</li></ul></li></ul><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>           6				 6						</span></span>
<span class="line"><span>         /   \\			   /   \\						</span></span>
<span class="line"><span>        3     7			  5     8						</span></span>
<span class="line"><span>       / \\        		 / \\   / 						</span></span>
<span class="line"><span>      2   5      ✅     4  3  6    ❌</span></span></code></pre></div><ul><li>平衡二叉搜索树: 左右两颗子树高度相差不能为1，并且左右两个子树分别也为 平衡二叉搜索树</li></ul><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>           6				  6						</span></span>
<span class="line"><span>         /   \\				/    						</span></span>
<span class="line"><span>        3     7			   3     						</span></span>
<span class="line"><span>       / \\        		  / \\    						</span></span>
<span class="line"><span>      4   5      ✅      4  5      ❌</span></span></code></pre></div><h3 id="_2、储存方式" tabindex="-1">2、储存方式 <a class="header-anchor" href="#_2、储存方式" aria-label="Permalink to &quot;2、储存方式&quot;">​</a></h3><ul><li>链式存储 通过左右指针 指向左右子树</li><li>顺序存储 利用数组保存二叉树，如果当前节点是i，那么他的左子树2i+1，右子树2i+2s（只适用于完全二叉树</li></ul><h3 id="_3、遍历" tabindex="-1">3、遍历 <a class="header-anchor" href="#_3、遍历" aria-label="Permalink to &quot;3、遍历&quot;">​</a></h3><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>		   1								</span></span>
<span class="line"><span>         /   \\			</span></span>
<span class="line"><span>        2     3				 </span></span>
<span class="line"><span>       / \\   / \\     		</span></span>
<span class="line"><span>      4   5 6   7</span></span></code></pre></div><h4 id="深度优先搜索-dfs" tabindex="-1">深度优先搜索 DFS <a class="header-anchor" href="#深度优先搜索-dfs" aria-label="Permalink to &quot;深度优先搜索 DFS&quot;">​</a></h4><p>沿着一条路径尽可能深的访问节点，知道没有子节点，在返回到上一层，遍历其他位访问的节点，直至所有节点都被访问完成</p><ul><li>前序遍历：中 左 右 <ul><li>遍历顺序：1 - 2 - 4 - 5 - 3 - 6 - 7</li></ul></li><li>中序遍历：左 中 右 <ul><li>遍历顺序：4 - 2 - 5 - 1 - 6 - 3 - 7</li></ul></li><li>后序遍历：左 右 中 <ul><li>遍历顺序：4 - 5 - 2 - 3 - 6 - 7 - 1</li></ul></li></ul><h4 id="广度优先搜索-bfs" tabindex="-1">广度优先搜索 BFS <a class="header-anchor" href="#广度优先搜索-bfs" aria-label="Permalink to &quot;广度优先搜索 BFS&quot;">​</a></h4><p>从起点开始，逐层访问节点，先访问近的，逐渐向外扩张，直至所有节点访问完毕 <br>遍历顺序：1 - 2 - 3 - 4 - 5 - 6 - 7</p>`,18),p=[e];function i(c,o,r,d,h,u){return s(),t("div",null,p)}const _=a(l,[["render",i]]);export{b as __pageData,_ as default};
