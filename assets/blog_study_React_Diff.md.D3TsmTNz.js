import{_ as s,c as i,o as a,a4 as n,ay as e}from"./chunks/framework.sZGJh8CM.js";const y=JSON.parse('{"title":"虚拟DOM","description":"","frontmatter":{"outline":"deep"},"headers":[],"relativePath":"blog/study/React/Diff.md","filePath":"blog/study/React/Diff.md"}'),l={name:"blog/study/React/Diff.md"},t=n('<h1 id="虚拟dom" tabindex="-1">虚拟DOM <a class="header-anchor" href="#虚拟dom" aria-label="Permalink to &quot;虚拟DOM&quot;">​</a></h1><hr><h3 id="虚拟dom-virtual-dom" tabindex="-1">虚拟DOM（Virtual DOM） <a class="header-anchor" href="#虚拟dom-virtual-dom" aria-label="Permalink to &quot;虚拟DOM（Virtual DOM）&quot;">​</a></h3><h3 id="一、什么是虚拟dom" tabindex="-1">一、什么是虚拟DOM <a class="header-anchor" href="#一、什么是虚拟dom" aria-label="Permalink to &quot;一、什么是虚拟DOM&quot;">​</a></h3><p>本质是JS跟DOM的一个映射缓存，形态上表现为一个能够描述DOM结构及其属性信息的JS对象 <img src="'+e+`" alt=""></p><h4 id="二、虚拟dom的价值到底是什么-解决了什么问题" tabindex="-1">二、虚拟DOM的价值到底是什么（解决了什么问题） <a class="header-anchor" href="#二、虚拟dom的价值到底是什么-解决了什么问题" aria-label="Permalink to &quot;二、虚拟DOM的价值到底是什么（解决了什么问题）&quot;">​</a></h4><p>1、研发体验/研发效率的问题<br> 2、跨平台多端开发 同一套虚拟DOM可以渲染在不同的载体<br> 3、“批量更新”</p><h3 id="diff算法" tabindex="-1">Diff算法 <a class="header-anchor" href="#diff算法" aria-label="Permalink to &quot;Diff算法&quot;">​</a></h3><h4 id="一、什么是diff算法" tabindex="-1">一、什么是diff算法 <a class="header-anchor" href="#一、什么是diff算法" aria-label="Permalink to &quot;一、什么是diff算法&quot;">​</a></h4><blockquote><p><strong>算法的核心就是复用节点</strong></p></blockquote><p>在v16之前:React通过递归直接生成虚拟DOM，setState触发重新渲染，对比生成新旧虚拟DOM，对比差异渲染真实的DOM<br> 在v16之后:为了优化性能，先将虚拟DOM转化为Fiber，也就是将树转换成链表，然后再渲染，整体渲染流程分成了两个阶段<br></p><p>render ： 从虚拟DOM转换成Fiber，并且对需要dom操作的节点打上 effectTag 的标记<br> commit：对有effectTag标记的fiber节点进行dom操作，并执行所有的effect副作用函数<br></p><blockquote><p>vdom -&gt; fiber 这个过程称之为reconcile（调和），是可以被打断的，由scheduler调度执行</p></blockquote><h4 id="二、react预设的三个限制" tabindex="-1">二、React预设的三个限制 <a class="header-anchor" href="#二、react预设的三个限制" aria-label="Permalink to &quot;二、React预设的三个限制&quot;">​</a></h4><p>1、只对同层级元素进行Diff。如果一个DOM元素前后跨越了层级，那么React不会尝试复用它<br> 2、两个不同类型的元素会产生不同的树。即销毁原组件，创建新组件。<br> 3、开发者可以通过Key 来暗示子元素在不同的渲染下保持稳</p><h4 id="三、具体实现" tabindex="-1">三、具体实现 <a class="header-anchor" href="#三、具体实现" aria-label="Permalink to &quot;三、具体实现&quot;">​</a></h4><p>入口函数 <code>reconcileChildFibers()</code></p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 根据newChild类型选择不同diff函数处理</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> reconcileChildFibers</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span></span>
<span class="line"><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">  returnFiber</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Fiber</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">  currentFirstChild</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Fiber</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> |</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> null</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">  newChild</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> any</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Fiber</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> |</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> null</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> isObject</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> typeof</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> newChild </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">===</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;object&#39;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> &amp;&amp;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> newChild </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!==</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> null</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (isObject) {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // object类型，可能是 REACT_ELEMENT_TYPE 或 REACT_PORTAL_TYPE</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    switch</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (newChild.$typeof) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">      case</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> REACT_ELEMENT_TYPE</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // 调用 reconcileSingleElement 处理</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">      // ...其他case</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">typeof</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> newChild </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">===</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;string&#39;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> ||</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> typeof</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> newChild </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">===</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;number&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 调用 reconcileSingleTextNode 处理</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">isArray</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(newChild)) {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 调用 reconcileChildrenArray 处理</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 一些其他情况调用处理函数</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 以上都没有命中，删除节点</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  return</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> deleteRemainingChildren</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(returnFiber, currentFirstChild);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h4 id="第一轮遍历-尝试逐个复用节点" tabindex="-1">第一轮遍历：尝试逐个复用节点 <a class="header-anchor" href="#第一轮遍历-尝试逐个复用节点" aria-label="Permalink to &quot;第一轮遍历：尝试逐个复用节点&quot;">​</a></h4><p>遍历JSX对象（newChildren 数组）去和Fiber节点对比（链表）<br> 判断 key 和 type（节点类型，如 div、p、span、函数组件名），如果都相同则复用，不同跳出整个遍历。</p><h4 id="第二轮遍历-处理剩下的节点" tabindex="-1">第二轮遍历：处理剩下的节点 <a class="header-anchor" href="#第二轮遍历-处理剩下的节点" aria-label="Permalink to &quot;第二轮遍历：处理剩下的节点&quot;">​</a></h4><p><strong>情况1：只剩旧Fiber节点</strong><br> 说明更新需要的新Fiber节点已经创建完毕，遍历剩余的旧Fiber节点依次执行删除操作（放入父fiber节点的deletions 数组中）</p><p><strong>情况2：只剩新JSX节点</strong><br> 说明旧的Fiber节点都已复用，遍历剩余的JSX节点依次执行插入操作 （打上Placement 标记）</p><p><strong>情况3：新旧子节点都有剩 （重点</strong>）<br> 将剩下的旧Fiber节点放入以key为key，以fiber为value的Map对象中，在遍历余下的JSX对象，通过key索引就能在map中找到对应的Fiber。</p><p><code>oldIndex</code>：旧Fiber节点中对应的索引 <br><code>lastplacedIndex</code>：最后一个可复用的节点在旧Fiber节点中的位置索引</p><p>如果 <code>oldIndex &gt;= lastPlacedIndex</code> 代表该可复用节点不需要移动 ，并将 <code>lastPlacedIndex = oldIndex; </code><br> 如果 <code>oldIndex &lt; lastplacedIndex </code>该可复用节点之前插入的位置索引小于这次更新需要插入的位置索引，代表该节点需要向右移动</p>`,26),h=[t];function p(k,r,d,c,o,E){return a(),i("div",null,h)}const F=s(l,[["render",p]]);export{y as __pageData,F as default};
