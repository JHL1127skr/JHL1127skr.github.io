import{_ as n,c as a,o as p,a4 as r,ag as e,ah as o}from"./chunks/framework.A-dsNYHP.js";const P=JSON.parse('{"title":"Npm&Yarn&Pnpm","description":"","frontmatter":{"outline":"deep"},"headers":[],"relativePath":"blog/study/Engineering/Npm&Yarn&Pnpm.md","filePath":"blog/study/Engineering/Npm&Yarn&Pnpm.md"}'),t={name:"blog/study/Engineering/Npm&Yarn&Pnpm.md"},m=r('<h1 id="npm-yarn-pnpm" tabindex="-1">Npm&amp;Yarn&amp;Pnpm <a class="header-anchor" href="#npm-yarn-pnpm" aria-label="Permalink to &quot;Npm&amp;Yarn&amp;Pnpm&quot;">​</a></h1><hr><h3 id="面试题" tabindex="-1">面试题 <a class="header-anchor" href="#面试题" aria-label="Permalink to &quot;面试题&quot;">​</a></h3><p><strong>pnmp相对于yarn/npm的优势</strong></p><ul><li>更快的依赖下载</li><li>更高效的利用磁盘空间</li><li>更为优秀的依赖管理</li></ul><h3 id="问题一-依赖嵌套-npm2" tabindex="-1">问题一：依赖嵌套（npm2 <a class="header-anchor" href="#问题一-依赖嵌套-npm2" aria-label="Permalink to &quot;问题一：依赖嵌套（npm2&quot;">​</a></h3><p>用 node 版本管理工具把 node 版本降到 4，那 npm 版本就是 2.x 了。</p><img src="'+e+'" style="zoom:50%;"><p>1、多个包难免会有公共依赖，同样的依赖复制多次，磁盘占用大，下载速度慢</p><p>2、致命问题 windows 的文件路径最长260多个字符，这样的嵌套会超过 windows路径的长度限制</p><h3 id="问题二-幽灵依赖-npm3-yarn" tabindex="-1">问题二：幽灵依赖 （npm3 yarn <a class="header-anchor" href="#问题二-幽灵依赖-npm3-yarn" aria-label="Permalink to &quot;问题二：幽灵依赖 （npm3 yarn&quot;">​</a></h3><p>yarn 将所有依赖 <strong>铺平</strong> 这样就不会依赖重复多次的问题，同时也解决了路路径名字问题</p><img src="'+o+'" style="zoom:50%;"><p>1、我们明明没有安装的 A包 但是却可以在JS中 引用，这是因为我们引用了B包，但是B包中依赖了A包，平铺在node_module中。如果某一天，我们不需要B包，那么代码中引用A包的代码将会报错</p><h3 id="主角-pnpm" tabindex="-1">主角：pnpm <a class="header-anchor" href="#主角-pnpm" aria-label="Permalink to &quot;主角：pnpm&quot;">​</a></h3><p><strong>优点一：节省磁盘</strong> pnpm安装的真实包，都存在一个系统的隐藏路径 .pnpm-store 文件中 ，项目中的依赖只是对真实包的引用。这样十个项目的node_module中相同的依赖只用下载一份在 隐藏文件中 引用即可</p><p><strong>优点二：效率快</strong> pnpm在你删除项目的某个依赖或者升级依赖的时候不会把store里的真实文件删除（除非执行 pnpm prune 指令 ，要求他杀出不被使用到的store）。在切换分支，版本切换不出错，且效率跟高</p><p><strong>优点三：依赖合理 不拍平</strong> 没有幽灵依赖，所有依赖都在 store中，只是没有把引用开放给你。</p><p><strong>优点四：支持workspace 可以做monorepo（微应用</strong></p>',19),s=[m];function i(l,d,_,h,c,g){return p(),a("div",null,s)}const b=n(t,[["render",i]]);export{P as __pageData,b as default};
