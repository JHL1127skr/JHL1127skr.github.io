import{_ as s,c as a,o as t,a4 as e,av as i,aw as l,ax as n}from"./chunks/framework.A-dsNYHP.js";const E=JSON.parse('{"title":"生命周期","description":"","frontmatter":{"outline":"deep"},"headers":[],"relativePath":"blog/study/React/Component.md","filePath":"blog/study/React/Component.md"}'),p={name:"blog/study/React/Component.md"},r=e('<h1 id="生命周期" tabindex="-1">生命周期 <a class="header-anchor" href="#生命周期" aria-label="Permalink to &quot;生命周期&quot;">​</a></h1><hr><div class="tip custom-block"><p class="custom-block-title">虚拟DOM：核心算法的基石</p><ul><li>组件初始化： render方法 -&gt; 生成虚拟DOM -&gt; ReactDOM.render -&gt; 真实DOM</li><li>组件更新： render方法 -&gt; 生成新的虚拟DOM -&gt;diff算法 -&gt; 定位出两次虚拟DOM的差异</li></ul></div><div class="tip custom-block"><p class="custom-block-title">组件化：工程化思想在框架中落地</p><ul><li>几乎所有可见/不可见的内容都可以被抽离为各种各样的组件，每个组件即是封闭的又是开放的</li><li>封闭：针对”渲染工作流“，每个组件只能处理内部的渲染逻辑</li><li>开放：基于”单项数据流“ 组件之间的互相通信，改变内部数据进而对渲染结构产生影响</li></ul></div><h3 id="拆解react生命周期" tabindex="-1">拆解React生命周期 <a class="header-anchor" href="#拆解react生命周期" aria-label="Permalink to &quot;拆解React生命周期&quot;">​</a></h3><blockquote><p>生命周期方法的本质：组件的“灵魂（render）”与“躯干（render以外的生命周期）”</p></blockquote><h3 id="一、react15的生命周期流程" tabindex="-1">一、React15的生命周期流程 <a class="header-anchor" href="#一、react15的生命周期流程" aria-label="Permalink to &quot;一、React15的生命周期流程&quot;">​</a></h3><p><img src="'+i+'" alt="图片"></p><p><strong>初始化</strong>：constructor -&gt; WillMount -&gt; render -&gt; DIdMount</p><p><strong>更新</strong>：</p><ul><li>1、父组件触发：componentWillReceiveProps(nextProps) -&gt; WillUpdate -&gt; redner -&gt; DIdUpdate</li></ul><blockquote><p>如果父组件导致组件重新渲染，即使props没有更改，也会调用此方法（componentReceiveProps）。如果只是想处理更改，请确保进行当前值与变更值的比较。 --React官方</p></blockquote><div class="warning custom-block"><p class="custom-block-title">WARNING</p><p>注意：componentWillReceiveProps(nextProps) 并不是由Props改变触发的，而是由父组件的更新触发的</p></div><ul><li>2、自身触发：shouldComponentUpdate(nextProps，nextState) -&gt; WillUpdate -&gt; redner -&gt; DIdUpdate</li></ul><p><strong>卸载</strong>：在父组件中被移除/组件设置的key 在父组件runder的过程中 与上次不一样</p><h3 id="二、react16的生命周期流程" tabindex="-1">二、React16的生命周期流程 <a class="header-anchor" href="#二、react16的生命周期流程" aria-label="Permalink to &quot;二、React16的生命周期流程&quot;">​</a></h3><p><img src="'+l+`" alt="图片"></p><h3 id="一、新增了两个生命周期" tabindex="-1">一、新增了两个生命周期 <a class="header-anchor" href="#一、新增了两个生命周期" aria-label="Permalink to &quot;一、新增了两个生命周期&quot;">​</a></h3><div class="language-jsx vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">jsx</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">static </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getDerivedStateFromProps</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(nextProps,prevState){</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  //static 静态方法 this为null</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  //函数返回结果将会被添加到state里面 </span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  //null 表示state不需要任何改变 </span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    flag:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><ol><li>静态方法：不依赖组件实例而存在，所以在方法内部访问不到this</li><li>两个参数：父组件的Props，组件自身的State</li><li>需要一个对象格式的返回值：需要用返回值更新state ，return null</li><li>并非覆盖式更新，针对某个属性的定向更新：更新完原有属性和更新属性共存</li></ol><div class="language-jsx vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">jsx</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getSnapshotBeforeUpdate</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(){</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  //return 的值 回传给 componentDidUpdate 里的 info</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  return</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> null</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">} </span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">componentDidUpdate</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(prevProps,prevState,info){}</span></span></code></pre></div><ol><li>返回值作为DidUpdate第三个参数传入</li></ol><h3 id="二、删除了三个will相关的生命周期" tabindex="-1">二、删除了三个Will相关的生命周期 <a class="header-anchor" href="#二、删除了三个will相关的生命周期" aria-label="Permalink to &quot;二、删除了三个Will相关的生命周期&quot;">​</a></h3><p><strong>前置条件</strong>:</p><p>每触发一次组件的更新 ，react就会构建一颗新的虚拟DOM树，通过与上一次的虚拟DOM进行diff，来实现DOM定向更新。这个漫长且不可打段的递归更新过程，将会带来用户体验成的巨大风险。渲染过程一旦开始就会牢牢占用主线程，直到递归彻底完成。浏览器没有办法处理渲染之外的是事情，若渲染时间过长，没有办法处理用户交互，就会导致页面卡顿或卡死。</p><p><strong>解决办法</strong>：</p><p>Fiber架构：对React核心算法的一次重写</p><p>Fiber会将一个大的更新任务拆解为许多小任务，会使原本同步的渲染过程变成可打断的异步模式。</p><p>根据“能否被打断”这一标准 React16生命周期被划分为 render 和 commit 两个阶段。render阶段在执行过程中 允许被打断，而commit阶段总是同步执行的</p><p>在Fiber机制下，render阶段是允许暂停，终止，和重启的。（重复执行一遍整个任务，而非接着上次执行接着往下走）导致render阶段的生命周期有可能被重复执行的。</p><p><strong>总结</strong>：</p><p>React为了解决之前的漫长不可打断的同步渲染进程带来的风险，推出Filer架构，使渲染流程变成可打断的异步模式。在Fiber机制下，三个Will相关的生命周期处于可以被打断的render阶段，render阶段使允许暂停、终止、和重启的。所以为了防止生命周期多次被调用导致出现BUG，进而删除和引入新的生命周期，同时也确保了生命周期的行为更加纯粹、可控、可预测。</p><h3 id="三、fiber架构对生命周期的影响" tabindex="-1">三、Fiber架构对生命周期的影响 <a class="header-anchor" href="#三、fiber架构对生命周期的影响" aria-label="Permalink to &quot;三、Fiber架构对生命周期的影响&quot;">​</a></h3><p><img src="`+n+'" alt="图片"></p>',34),o=[r];function c(h,d,k,g,u,m){return t(),a("div",null,o)}const _=s(p,[["render",c]]);export{E as __pageData,_ as default};
