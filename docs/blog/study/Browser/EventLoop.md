---
outline: deep
---

# 事件循环机制

> 进程：进程是计算机中正在运行的程序的实例，每个进程都有自己的独立的内存，彼此相互隔离。多个进程可以同时运行，通过进程间通信进行交互.

> 线程：线程是进程中的一个执行单元。一个进程那可以有多个线程，彼此之间可以更方便的通信，因为共享同一片内存地址。

### 浏览器进程模型

浏览器是一个多线程多进程的应用，为了避免相互影响，减少连环崩坏的的几率。

> 可以在浏览器的任务管理器中查看所有进程

1、浏览器进程： <br/> &emsp;&emsp;主要负责界面显示、用户交互、子进程管理。浏览器进程内部会启动多个线程处理不同任务

2、网络进程：
<br/> &emsp;&emsp;负责加载网络资源，网络进程内会有多个线程来处理不同的网络任务

3、**渲染进程：**
<br/> &emsp;&emsp;渲染进程启动，会开启一个渲染主线程，主要负责 HTML、CSS、JS 代码。目前浏览器一个站点一个渲染进程，以保证不同标签页之间互不影响

### 渲染主线程

渲染主线程需要做很多事情，包括但不限于：解析 HTML、解析 CSS、计算样式、布局、图层、渲染页面、处理定时器、执行全局 JS 等等...

::: tip 问：为什么渲染进程不适用多个线程来处理这些事情
简化了浏览器设计并避免了竞争条件，确保了可预测的事件处理和用户界面更新。这一设计选择符合 JavaScript 的单线程本质，减少了开发复杂性，同时浏览器通过多进程模型实现并行处理，提高了稳定性和安全性。
:::

### 事件循环/消息循环

这么多任务，渲染主线程该如何去调度任务呢？**“排队”**
![图片](/blog/eventloop_01.png)
1、在最开始的时候，渲染主线程会进入一个无限循环。`（for(,,)`

2、每一次循环都会检查消息队列中是否有任务存在。如果有，就取出第一个任务执行，执行完一个后进行下一个循环；如果没有则进入休眠状态

3、其他所有线程（包括其他进程中的线程（指浏览器进程中的用户交互）可以随时向消息队列中添加任务。新任务会加到消息队列中的末尾。再添加新任务时，如果住线程处于休眠状态，则会将其唤醒并执行任务

### 异步任务

在代码执行过程，会遇到一些无法立刻执行的任务比如

-   计时器：`setTimeout`、`setInterval`
-   网络任务：`XHR`、`Fetch`
-   用户操作：`addEventListener`

如果让主线程等待这些任务的时机到达，就会导致主线程长期处于阻塞状态，从而导致浏览器卡死
![图片](/blog/eventloop_02.png)

**主线程任何时候都不能阻塞！**

因此，浏览器选择异步来解决这个问题，交给其他线程处理，完成之后加入队列末尾
![图片](/blog/eventloop_03.png)

::: tip 问：如何理解 JS 中的异步

JS 是一门单线程的语言，这是因为它运行在浏览器的渲染主线程中，而渲染主线程只有一个

如果使用同步的方式，就极有可能导致主线程产生阻塞，从而导致消息队列中的很多其他任务无法得到执行。这样一来，一方面会导致繁忙的主线程白白的消耗时间，另一方面导致页面无法及时更新，给用户造成卡死现象。

所以浏览器采用异步的方式来避免。具体做法是当某些任务发生时，比如计时器、网络、事件监听，主线程将任务交给其他线程去处理，自身立即结束任务的执行，转而执行后续代码。当其他线程完成时，将事先传递的回调函数包装成任务，加入到消息队列的末尾排队，等待主线程调度执行。

在这种异步模式下，浏览器永不阻塞，从而最大限度的保证了单线程的流畅运行。
:::

### 消息队列中的优先级

任务是没有优先级的，在消息队列中先进先出，但是消息队列有。

根据 W3C 解释：

-   每个任务都有一个任务类型，同一类型必须在同一个队列，不同类型的任务可以分属在不同队列。在一次循环中，浏览器可以根据实际情况从不同的队列中取出任务执行
-   浏览器必须准备好一个微任务队列，微任务对列中的任务优先所有其他任务

Chrome 的实现中，至少包含下面的队列：

-   延时队列：用于存放计时器到达后的回调任务，优先级「中」
-   交互队列：用于存放用户操作后产生的事件处理任务，优先级「高」
-   微任务队列：储存最快执行的任务，优先级「最高」

添加到微任务队列的方法:

-   Promise.then
-   MutationObserver
-   process.nextTick

::: tip 问：阐述一下 JS 中的事件循环
事件循环又叫消息循环，是浏览器渲染主线程的工作方式。

他是一个开启就不会结束的 for 循环，每次循环在消息队列中取出第一个任务执行，而且他线程只需要在合适的时候把任务添加到队列末尾即可

过去吧队列分成宏任务队列和微任务队列。这中说法已经满足不了现在的浏览器环境，取而代之的是一种更加多变的处理方式。

跟据 W3C 的解释，每个任务有不同的类型，同种类型的任务必须在同一个队列中，不同任务可以属于不同队列。不同任务队列有不同的优先级，在一次循环中，由浏览器自行决定取哪一个队列的任务。但是浏览器必须有一个微任务队列，且微任务队列的任务一定具有最高优先级，优先调度执行
:::

### 例题：

```js
console.log("aaa");
(async () => {
	console.log(111);
})().then(() => {
	console.log(222);
});
console.log("bbb");
//a 1 b 2
```

```js
console.log("aaa");
(async () => {
	console.log(111);
	await console.log(222);
	console.log(333);
})().then(() => {
	console.log(444);
});
console.log("ddd");
//a 1 2 d 3 4
```
```js
const fn1 = async () => {
	console.log(1);
	await fn2();
	console.log(2);
};
const fn2 = async () => {
	// ? 第一组
	await setTimeout(() => {
		Promise.resolve().then(() => {
			console.log(3);
		});
		console.log(4);
	}, 0);
	// ? 第二组
	// await (async () => {
	// 	await (() => {
	// 		console.log(3);
	// 	})();
	// 	console.log(4);
	// })();
	// ? 第三组
	// await (async () => {
	// 	Promise.resolve().then(() => {
	// 		console.log(3);
	// 	});
	// 	console.log(4);
	// })();
	// ? 第四组
	// await Promise.resolve().then(() => {
	// 	Promise.resolve().then(() => {
	// 		console.log(3);
	// 	});
	// 	console.log(4);
	// });
};
const fn3 = async () => {
	Promise.resolve().then(() => {
		console.log(6);
	});
};
fn1();
console.log(7);
fn3();
```