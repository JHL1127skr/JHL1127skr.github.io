---
outline: deep
---
# React 事件机制
---

### React 事件机制（v16 旧）

> 事件委托：利用事件冒泡的特性，把多个子元素的同一类型的监听逻辑合并到父元素上通过一个监听函数来管理的行为

##### 一、React 事件系统是如何工作的

React 事件系统沿袭了事件委托的思想，在 React 中，除了少数特殊的不可冒泡的事件无法被事件系统处理外，绝大部分的事件都不会被绑定在具体的元素上，而是统一被绑定在页面的 document 上。

**当事件在具体的 DOM 节点上被触发后，最终都会冒泡到 document 上，document 上所绑定的统一的事件处理程序会将事件分发到具体的实例。**

在分发事件之前，React 首先会对事件进行包装，把原生 DOM 事件包装成**合成事件**

#### 二、合成事件

合成事件是 React 自定义的事件对象，符合 W3C 规范。**在底层磨平不同浏览器的差异，在上层向开发者暴露统一的、稳定的、与 DOM 原声事件相同的事件接口**

虽然合成事件并不是原生 DOM 事件，但它保存了原生 DOM 事件的引用，可通过合成事件的`e.nativeEvent` 属性访问到

#### 三、合成事件池

当一个事件被触发时，React 会创建一个**合成事件对象**，并传递给事件处理函数。当函数执行完之后，合成时间对象上的所有属性都将被废弃并丢回合成事件池。当下一个事件触发时会尝试在事件池中获取一个时间对象，而不是重新创建。

通过合成事件池，React 可以大大节省内存，不会频繁的创建和销毁事件对象，减轻了垃圾回收的压力。

#### 四、缺点与隐患

##### 1、异步访问事件对象

由于事件对象会被事件池回收，所以不能以异步的方式访问

```jsx
const handleClick = (event) => {
	console.log(e);

	setTimeout(() => {
		console.log(e); // Warning 报错
	});
};
```

当然 React 提供持久化合成事件的方法

```jsx
const handleClick = (event) => {
	console.log(e);
	e.persist();

	setTimeout(() => {
		console.log(e);
	});
};
```

##### 2、多个 React 应用

如果一个页面上存在多个 React 应用，由于他们都会在顶层的 document 注册事件，那么就会导致如果其中一个应用调用了 `e.stopPropagetion()`也无法阻止事件冒泡，因为真实事件早已经传播到了 document

##### 3、无法阻止原生的事件的捕获冒泡阶段

React 是统一冒泡到 document 之后触发绑定的回调函数中模拟 **捕获-冒泡** 的行为，如果在 React 事件中调用 `e.sttopPropagetion()`是没有办法阻止原生事件的冒泡的，因为原生的捕获和冒泡已经执行完了

### React 事件机制（v17 新）

### 一、跟旧版相比

1、v16 React 将事件委托在 document 上 v17 则委托在**根节点**上 -- 对应问题 2

2、去除了事件池 -- 对应问题 1

3、对标原生事件的执行顺序 -- 对应问题 3

4、scroll 事件不再冒泡

![图片](/blog/Event02.png)